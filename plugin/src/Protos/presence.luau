--!strict
--!nolint LocalUnused
--!nolint ImportUnused
--# selene: allow(empty_if, if_same_then_else, manual_table_clone, unused_variable)
-- This file was @autogenerated by protoc-gen-luau
local proto = require(script.Parent.proto)
local typeRegistry = require(script.Parent.proto.typeRegistry)

type _Messages = {
	UpdatePresenceRequest: _UpdatePresenceRequestMessage,
	UpdatePresenceResponse: _UpdatePresenceResponseMessage,
	ClearPresenceRequest: _ClearPresenceRequestMessage,
	ClearPresenceResponse: _ClearPresenceResponseMessage,
	DiscordPresence: _DiscordPresenceMessage,
	PresenceTimestamps: _PresenceTimestampsMessage,
	PresenceAssets: _PresenceAssetsMessage,
}
local messages: _Messages = {} :: _Messages

local _common = require(script.Parent.common)

type _UpdatePresenceRequestImpl = {
	__index: _UpdatePresenceRequestImpl,
	new: (fields: _UpdatePresenceRequestPartialFields?) -> UpdatePresenceRequest,
	encode: (self: UpdatePresenceRequest) -> buffer,
	decode: (input: buffer) -> UpdatePresenceRequest,
	jsonEncode: (self: UpdatePresenceRequest) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> UpdatePresenceRequest,
	descriptor: proto.Descriptor,
}

type _UpdatePresenceRequestFields = {
	auth_token: string,
	client_key: string,
	presence: DiscordPresence?,
}

type _UpdatePresenceRequestPartialFields = {
	auth_token: string?,
	client_key: string?,
	presence: DiscordPresence?,
}

export type UpdatePresenceRequest = typeof(setmetatable(
	{} :: _UpdatePresenceRequestFields,
	{} :: _UpdatePresenceRequestImpl
))
type _UpdatePresenceRequestMessage = proto.Message<UpdatePresenceRequest, _UpdatePresenceRequestPartialFields>

type _UpdatePresenceResponseImpl = {
	__index: _UpdatePresenceResponseImpl,
	new: (fields: _UpdatePresenceResponsePartialFields?) -> UpdatePresenceResponse,
	encode: (self: UpdatePresenceResponse) -> buffer,
	decode: (input: buffer) -> UpdatePresenceResponse,
	jsonEncode: (self: UpdatePresenceResponse) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> UpdatePresenceResponse,
	descriptor: proto.Descriptor,
}

type _UpdatePresenceResponseFields = {
	pending_auth_token: string?,
	updated_accounts: number,
	failed_accounts: number,
}

type _UpdatePresenceResponsePartialFields = {
	pending_auth_token: string?,
	updated_accounts: number?,
	failed_accounts: number?,
}

export type UpdatePresenceResponse = typeof(setmetatable(
	{} :: _UpdatePresenceResponseFields,
	{} :: _UpdatePresenceResponseImpl
))
type _UpdatePresenceResponseMessage = proto.Message<UpdatePresenceResponse, _UpdatePresenceResponsePartialFields>

type _ClearPresenceRequestImpl = {
	__index: _ClearPresenceRequestImpl,
	new: (fields: _ClearPresenceRequestPartialFields?) -> ClearPresenceRequest,
	encode: (self: ClearPresenceRequest) -> buffer,
	decode: (input: buffer) -> ClearPresenceRequest,
	jsonEncode: (self: ClearPresenceRequest) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> ClearPresenceRequest,
	descriptor: proto.Descriptor,
}

type _ClearPresenceRequestFields = {}

type _ClearPresenceRequestPartialFields = {}

export type ClearPresenceRequest = typeof(setmetatable(
	{} :: _ClearPresenceRequestFields,
	{} :: _ClearPresenceRequestImpl
))
type _ClearPresenceRequestMessage = proto.Message<ClearPresenceRequest, _ClearPresenceRequestPartialFields>

type _ClearPresenceResponseImpl = {
	__index: _ClearPresenceResponseImpl,
	new: (fields: _ClearPresenceResponsePartialFields?) -> ClearPresenceResponse,
	encode: (self: ClearPresenceResponse) -> buffer,
	decode: (input: buffer) -> ClearPresenceResponse,
	jsonEncode: (self: ClearPresenceResponse) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> ClearPresenceResponse,
	descriptor: proto.Descriptor,
}

type _ClearPresenceResponseFields = {
	cleared_accounts: number,
	failed_accounts: number,
}

type _ClearPresenceResponsePartialFields = {
	cleared_accounts: number?,
	failed_accounts: number?,
}

export type ClearPresenceResponse = typeof(setmetatable(
	{} :: _ClearPresenceResponseFields,
	{} :: _ClearPresenceResponseImpl
))
type _ClearPresenceResponseMessage = proto.Message<ClearPresenceResponse, _ClearPresenceResponsePartialFields>

type _DiscordPresenceImpl = {
	__index: _DiscordPresenceImpl,
	new: (fields: _DiscordPresencePartialFields?) -> DiscordPresence,
	encode: (self: DiscordPresence) -> buffer,
	decode: (input: buffer) -> DiscordPresence,
	jsonEncode: (self: DiscordPresence) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> DiscordPresence,
	descriptor: proto.Descriptor,
}

type _DiscordPresenceFields = {
	details: string?,
	state: string?,
	timestamps: PresenceTimestamps?,
	assets: PresenceAssets?,
}

type _DiscordPresencePartialFields = {
	details: string?,
	state: string?,
	timestamps: PresenceTimestamps?,
	assets: PresenceAssets?,
}

export type DiscordPresence = typeof(setmetatable({} :: _DiscordPresenceFields, {} :: _DiscordPresenceImpl))
type _DiscordPresenceMessage = proto.Message<DiscordPresence, _DiscordPresencePartialFields>

type _PresenceTimestampsImpl = {
	__index: _PresenceTimestampsImpl,
	new: (fields: _PresenceTimestampsPartialFields?) -> PresenceTimestamps,
	encode: (self: PresenceTimestamps) -> buffer,
	decode: (input: buffer) -> PresenceTimestamps,
	jsonEncode: (self: PresenceTimestamps) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> PresenceTimestamps,
	descriptor: proto.Descriptor,
}

type _PresenceTimestampsFields = {
	start_unix: number?,
	end_unix: number?,
}

type _PresenceTimestampsPartialFields = {
	start_unix: number?,
	end_unix: number?,
}

export type PresenceTimestamps = typeof(setmetatable({} :: _PresenceTimestampsFields, {} :: _PresenceTimestampsImpl))
type _PresenceTimestampsMessage = proto.Message<PresenceTimestamps, _PresenceTimestampsPartialFields>

type _PresenceAssetsImpl = {
	__index: _PresenceAssetsImpl,
	new: (fields: _PresenceAssetsPartialFields?) -> PresenceAssets,
	encode: (self: PresenceAssets) -> buffer,
	decode: (input: buffer) -> PresenceAssets,
	jsonEncode: (self: PresenceAssets) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> PresenceAssets,
	descriptor: proto.Descriptor,
}

type _PresenceAssetsFields = {
	large_image: string?,
	large_text: string?,
	small_image: string?,
	small_text: string?,
}

type _PresenceAssetsPartialFields = {
	large_image: string?,
	large_text: string?,
	small_image: string?,
	small_text: string?,
}

export type PresenceAssets = typeof(setmetatable({} :: _PresenceAssetsFields, {} :: _PresenceAssetsImpl))
type _PresenceAssetsMessage = proto.Message<PresenceAssets, _PresenceAssetsPartialFields>

do
	local _UpdatePresenceRequestImpl = {}
	_UpdatePresenceRequestImpl.__index = _UpdatePresenceRequestImpl

	function _UpdatePresenceRequestImpl.new(data: _UpdatePresenceRequestPartialFields?): UpdatePresenceRequest
		return setmetatable({
			auth_token = if data == nil or data.auth_token == nil then "" else data.auth_token,
			client_key = if data == nil or data.client_key == nil then "" else data.client_key,
			presence = if data == nil or data.presence == nil then nil else data.presence,
		}, _UpdatePresenceRequestImpl :: _UpdatePresenceRequestImpl)
	end

	function _UpdatePresenceRequestImpl.encode(self: UpdatePresenceRequest): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.auth_token ~= nil and self.auth_token ~= "" then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.auth_token)
		end

		if self.client_key ~= nil and self.client_key ~= "" then
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.client_key)
		end

		if self.presence ~= nil then
			local encoded = self.presence:encode()
			output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _UpdatePresenceRequestImpl.decode(input: buffer): UpdatePresenceRequest
		local self = _UpdatePresenceRequestImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.auth_token = buffer.tostring(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.client_key = buffer.tostring(value)
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.presence = messages.DiscordPresence.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _UpdatePresenceRequestImpl.jsonEncode(self: UpdatePresenceRequest): any
		local output = {}

		if self.auth_token ~= nil and self.auth_token ~= "" then
			output.authToken = self.auth_token
		end

		if self.client_key ~= nil and self.client_key ~= "" then
			output.clientKey = self.client_key
		end

		if self.presence ~= nil then
			output.presence = self.presence:jsonEncode()
		end

		return output
	end

	function _UpdatePresenceRequestImpl.jsonDecode(input: { [string]: any }): UpdatePresenceRequest
		local self = _UpdatePresenceRequestImpl.new()

		if input.auth_token ~= nil then
			self.auth_token = input.auth_token
		end

		if input.authToken ~= nil then
			self.auth_token = input.authToken
		end

		if input.client_key ~= nil then
			self.client_key = input.client_key
		end

		if input.clientKey ~= nil then
			self.client_key = input.clientKey
		end

		if input.presence ~= nil then
			self.presence = messages.DiscordPresence.jsonDecode(input.presence)
		end

		return self
	end

	_UpdatePresenceRequestImpl.descriptor = {
		name = "UpdatePresenceRequest",
		fullName = "srp.presence.UpdatePresenceRequest",
	}

	messages.UpdatePresenceRequest = _UpdatePresenceRequestImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.UpdatePresenceRequest)
end

do
	local _UpdatePresenceResponseImpl = {}
	_UpdatePresenceResponseImpl.__index = _UpdatePresenceResponseImpl

	function _UpdatePresenceResponseImpl.new(data: _UpdatePresenceResponsePartialFields?): UpdatePresenceResponse
		return setmetatable({
			pending_auth_token = if data == nil or data.pending_auth_token == nil then nil else data.pending_auth_token,
			updated_accounts = if data == nil or data.updated_accounts == nil then 0 else data.updated_accounts,
			failed_accounts = if data == nil or data.failed_accounts == nil then 0 else data.failed_accounts,
		}, _UpdatePresenceResponseImpl :: _UpdatePresenceResponseImpl)
	end

	function _UpdatePresenceResponseImpl.encode(self: UpdatePresenceResponse): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.pending_auth_token ~= nil then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.pending_auth_token)
		end

		if self.updated_accounts ~= nil and self.updated_accounts ~= 0 then
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, self.updated_accounts)
		end

		if self.failed_accounts ~= nil and self.failed_accounts ~= 0 then
			output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, self.failed_accounts)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _UpdatePresenceResponseImpl.decode(input: buffer): UpdatePresenceResponse
		local self = _UpdatePresenceResponseImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 2 then
					local value
					value, cursor = proto.readVarIntI32(input, cursor)
					self.updated_accounts = value
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readVarIntI32(input, cursor)
					self.failed_accounts = value
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.pending_auth_token = buffer.tostring(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _UpdatePresenceResponseImpl.jsonEncode(self: UpdatePresenceResponse): any
		local output = {}

		if self.pending_auth_token ~= nil then
			output.pendingAuthToken = self.pending_auth_token
		end

		if self.updated_accounts ~= nil and self.updated_accounts ~= 0 then
			output.updatedAccounts = self.updated_accounts
		end

		if self.failed_accounts ~= nil and self.failed_accounts ~= 0 then
			output.failedAccounts = self.failed_accounts
		end

		return output
	end

	function _UpdatePresenceResponseImpl.jsonDecode(input: { [string]: any }): UpdatePresenceResponse
		local self = _UpdatePresenceResponseImpl.new()

		if input.pending_auth_token ~= nil then
			self.pending_auth_token = input.pending_auth_token
		end

		if input.pendingAuthToken ~= nil then
			self.pending_auth_token = input.pendingAuthToken
		end

		if input.updated_accounts ~= nil then
			self.updated_accounts = input.updated_accounts
		end

		if input.updatedAccounts ~= nil then
			self.updated_accounts = input.updatedAccounts
		end

		if input.failed_accounts ~= nil then
			self.failed_accounts = input.failed_accounts
		end

		if input.failedAccounts ~= nil then
			self.failed_accounts = input.failedAccounts
		end

		return self
	end

	_UpdatePresenceResponseImpl.descriptor = {
		name = "UpdatePresenceResponse",
		fullName = "srp.presence.UpdatePresenceResponse",
	}

	messages.UpdatePresenceResponse = _UpdatePresenceResponseImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.UpdatePresenceResponse)
end

do
	local _ClearPresenceRequestImpl = {}
	_ClearPresenceRequestImpl.__index = _ClearPresenceRequestImpl

	function _ClearPresenceRequestImpl.new(data: _ClearPresenceRequestPartialFields?): ClearPresenceRequest
		return setmetatable({}, _ClearPresenceRequestImpl :: _ClearPresenceRequestImpl)
	end

	function _ClearPresenceRequestImpl.encode(self: ClearPresenceRequest): buffer
		local output = buffer.create(0)
		local cursor = 0

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _ClearPresenceRequestImpl.decode(input: buffer): ClearPresenceRequest
		local self = _ClearPresenceRequestImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				-- No fields

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _ClearPresenceRequestImpl.jsonEncode(self: ClearPresenceRequest): any
		local output = {}

		return output
	end

	function _ClearPresenceRequestImpl.jsonDecode(input: { [string]: any }): ClearPresenceRequest
		local self = _ClearPresenceRequestImpl.new()

		return self
	end

	_ClearPresenceRequestImpl.descriptor = {
		name = "ClearPresenceRequest",
		fullName = "srp.presence.ClearPresenceRequest",
	}

	messages.ClearPresenceRequest = _ClearPresenceRequestImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.ClearPresenceRequest)
end

do
	local _ClearPresenceResponseImpl = {}
	_ClearPresenceResponseImpl.__index = _ClearPresenceResponseImpl

	function _ClearPresenceResponseImpl.new(data: _ClearPresenceResponsePartialFields?): ClearPresenceResponse
		return setmetatable({
			cleared_accounts = if data == nil or data.cleared_accounts == nil then 0 else data.cleared_accounts,
			failed_accounts = if data == nil or data.failed_accounts == nil then 0 else data.failed_accounts,
		}, _ClearPresenceResponseImpl :: _ClearPresenceResponseImpl)
	end

	function _ClearPresenceResponseImpl.encode(self: ClearPresenceResponse): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.cleared_accounts ~= nil and self.cleared_accounts ~= 0 then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, self.cleared_accounts)
		end

		if self.failed_accounts ~= nil and self.failed_accounts ~= 0 then
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, self.failed_accounts)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _ClearPresenceResponseImpl.decode(input: buffer): ClearPresenceResponse
		local self = _ClearPresenceResponseImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 1 then
					local value
					value, cursor = proto.readVarIntI32(input, cursor)
					self.cleared_accounts = value
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readVarIntI32(input, cursor)
					self.failed_accounts = value
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				-- No fields

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _ClearPresenceResponseImpl.jsonEncode(self: ClearPresenceResponse): any
		local output = {}

		if self.cleared_accounts ~= nil and self.cleared_accounts ~= 0 then
			output.clearedAccounts = self.cleared_accounts
		end

		if self.failed_accounts ~= nil and self.failed_accounts ~= 0 then
			output.failedAccounts = self.failed_accounts
		end

		return output
	end

	function _ClearPresenceResponseImpl.jsonDecode(input: { [string]: any }): ClearPresenceResponse
		local self = _ClearPresenceResponseImpl.new()

		if input.cleared_accounts ~= nil then
			self.cleared_accounts = input.cleared_accounts
		end

		if input.clearedAccounts ~= nil then
			self.cleared_accounts = input.clearedAccounts
		end

		if input.failed_accounts ~= nil then
			self.failed_accounts = input.failed_accounts
		end

		if input.failedAccounts ~= nil then
			self.failed_accounts = input.failedAccounts
		end

		return self
	end

	_ClearPresenceResponseImpl.descriptor = {
		name = "ClearPresenceResponse",
		fullName = "srp.presence.ClearPresenceResponse",
	}

	messages.ClearPresenceResponse = _ClearPresenceResponseImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.ClearPresenceResponse)
end

do
	local _DiscordPresenceImpl = {}
	_DiscordPresenceImpl.__index = _DiscordPresenceImpl

	function _DiscordPresenceImpl.new(data: _DiscordPresencePartialFields?): DiscordPresence
		return setmetatable({
			details = if data == nil or data.details == nil then nil else data.details,
			state = if data == nil or data.state == nil then nil else data.state,
			timestamps = if data == nil or data.timestamps == nil then nil else data.timestamps,
			assets = if data == nil or data.assets == nil then nil else data.assets,
		}, _DiscordPresenceImpl :: _DiscordPresenceImpl)
	end

	function _DiscordPresenceImpl.encode(self: DiscordPresence): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.details ~= nil then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.details)
		end

		if self.state ~= nil then
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.state)
		end

		if self.timestamps ~= nil then
			local encoded = self.timestamps:encode()
			output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.assets ~= nil then
			local encoded = self.assets:encode()
			output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _DiscordPresenceImpl.decode(input: buffer): DiscordPresence
		local self = _DiscordPresenceImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.details = buffer.tostring(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.state = buffer.tostring(value)
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.timestamps = messages.PresenceTimestamps.decode(value)
					continue
				elseif field == 4 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.assets = messages.PresenceAssets.decode(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _DiscordPresenceImpl.jsonEncode(self: DiscordPresence): any
		local output = {}

		if self.details ~= nil then
			output.details = self.details
		end

		if self.state ~= nil then
			output.state = self.state
		end

		if self.timestamps ~= nil then
			output.timestamps = self.timestamps:jsonEncode()
		end

		if self.assets ~= nil then
			output.assets = self.assets:jsonEncode()
		end

		return output
	end

	function _DiscordPresenceImpl.jsonDecode(input: { [string]: any }): DiscordPresence
		local self = _DiscordPresenceImpl.new()

		if input.details ~= nil then
			self.details = input.details
		end

		if input.state ~= nil then
			self.state = input.state
		end

		if input.timestamps ~= nil then
			self.timestamps = messages.PresenceTimestamps.jsonDecode(input.timestamps)
		end

		if input.assets ~= nil then
			self.assets = messages.PresenceAssets.jsonDecode(input.assets)
		end

		return self
	end

	_DiscordPresenceImpl.descriptor = {
		name = "DiscordPresence",
		fullName = "srp.presence.DiscordPresence",
	}

	messages.DiscordPresence = _DiscordPresenceImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.DiscordPresence)
end

do
	local _PresenceTimestampsImpl = {}
	_PresenceTimestampsImpl.__index = _PresenceTimestampsImpl

	function _PresenceTimestampsImpl.new(data: _PresenceTimestampsPartialFields?): PresenceTimestamps
		return setmetatable({
			start_unix = if data == nil or data.start_unix == nil then nil else data.start_unix,
			end_unix = if data == nil or data.end_unix == nil then nil else data.end_unix,
		}, _PresenceTimestampsImpl :: _PresenceTimestampsImpl)
	end

	function _PresenceTimestampsImpl.encode(self: PresenceTimestamps): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.start_unix ~= nil then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, self.start_unix)
		end

		if self.end_unix ~= nil then
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, self.end_unix)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _PresenceTimestampsImpl.decode(input: buffer): PresenceTimestamps
		local self = _PresenceTimestampsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 1 then
					local value
					value, cursor = proto.readVarIntI64(input, cursor)
					self.start_unix = value
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readVarIntI64(input, cursor)
					self.end_unix = value
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				-- No fields

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _PresenceTimestampsImpl.jsonEncode(self: PresenceTimestamps): any
		local output = {}

		if self.start_unix ~= nil then
			output.startUnix = self.start_unix
		end

		if self.end_unix ~= nil then
			output.endUnix = self.end_unix
		end

		return output
	end

	function _PresenceTimestampsImpl.jsonDecode(input: { [string]: any }): PresenceTimestamps
		local self = _PresenceTimestampsImpl.new()

		if input.start_unix ~= nil then
			self.start_unix = input.start_unix
		end

		if input.startUnix ~= nil then
			self.start_unix = input.startUnix
		end

		if input.end_unix ~= nil then
			self.end_unix = input.end_unix
		end

		if input.endUnix ~= nil then
			self.end_unix = input.endUnix
		end

		return self
	end

	_PresenceTimestampsImpl.descriptor = {
		name = "PresenceTimestamps",
		fullName = "srp.presence.PresenceTimestamps",
	}

	messages.PresenceTimestamps = _PresenceTimestampsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.PresenceTimestamps)
end

do
	local _PresenceAssetsImpl = {}
	_PresenceAssetsImpl.__index = _PresenceAssetsImpl

	function _PresenceAssetsImpl.new(data: _PresenceAssetsPartialFields?): PresenceAssets
		return setmetatable({
			large_image = if data == nil or data.large_image == nil then nil else data.large_image,
			large_text = if data == nil or data.large_text == nil then nil else data.large_text,
			small_image = if data == nil or data.small_image == nil then nil else data.small_image,
			small_text = if data == nil or data.small_text == nil then nil else data.small_text,
		}, _PresenceAssetsImpl :: _PresenceAssetsImpl)
	end

	function _PresenceAssetsImpl.encode(self: PresenceAssets): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.large_image ~= nil then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.large_image)
		end

		if self.large_text ~= nil then
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.large_text)
		end

		if self.small_image ~= nil then
			output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.small_image)
		end

		if self.small_text ~= nil then
			output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.small_text)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _PresenceAssetsImpl.decode(input: buffer): PresenceAssets
		local self = _PresenceAssetsImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.large_image = buffer.tostring(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.large_text = buffer.tostring(value)
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.small_image = buffer.tostring(value)
					continue
				elseif field == 4 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.small_text = buffer.tostring(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _PresenceAssetsImpl.jsonEncode(self: PresenceAssets): any
		local output = {}

		if self.large_image ~= nil then
			output.largeImage = self.large_image
		end

		if self.large_text ~= nil then
			output.largeText = self.large_text
		end

		if self.small_image ~= nil then
			output.smallImage = self.small_image
		end

		if self.small_text ~= nil then
			output.smallText = self.small_text
		end

		return output
	end

	function _PresenceAssetsImpl.jsonDecode(input: { [string]: any }): PresenceAssets
		local self = _PresenceAssetsImpl.new()

		if input.large_image ~= nil then
			self.large_image = input.large_image
		end

		if input.largeImage ~= nil then
			self.large_image = input.largeImage
		end

		if input.large_text ~= nil then
			self.large_text = input.large_text
		end

		if input.largeText ~= nil then
			self.large_text = input.largeText
		end

		if input.small_image ~= nil then
			self.small_image = input.small_image
		end

		if input.smallImage ~= nil then
			self.small_image = input.smallImage
		end

		if input.small_text ~= nil then
			self.small_text = input.small_text
		end

		if input.smallText ~= nil then
			self.small_text = input.smallText
		end

		return self
	end

	_PresenceAssetsImpl.descriptor = {
		name = "PresenceAssets",
		fullName = "srp.presence.PresenceAssets",
	}

	messages.PresenceAssets = _PresenceAssetsImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.PresenceAssets)
end

return {
	UpdatePresenceRequest = messages.UpdatePresenceRequest,
	UpdatePresenceResponse = messages.UpdatePresenceResponse,
	ClearPresenceRequest = messages.ClearPresenceRequest,
	ClearPresenceResponse = messages.ClearPresenceResponse,
	DiscordPresence = messages.DiscordPresence,
	PresenceTimestamps = messages.PresenceTimestamps,
	PresenceAssets = messages.PresenceAssets,
}

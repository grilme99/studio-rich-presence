--!strict
--!nolint LocalUnused
--!nolint ImportUnused
--# selene: allow(empty_if, if_same_then_else, manual_table_clone, unused_variable)
-- This file was @autogenerated by protoc-gen-luau
local proto = require(script.Parent.proto)
local typeRegistry = require(script.Parent.proto.typeRegistry)

type _Messages = {
	ListAccountsRequest: _ListAccountsRequestMessage,
	ListAccountsResponse: _ListAccountsResponseMessage,
	LinkedAccount: _LinkedAccountMessage,
}
local messages: _Messages = {} :: _Messages

type _ListAccountsRequestImpl = {
	__index: _ListAccountsRequestImpl,
	new: (fields: _ListAccountsRequestPartialFields?) -> ListAccountsRequest,
	encode: (self: ListAccountsRequest) -> buffer,
	decode: (input: buffer) -> ListAccountsRequest,
	jsonEncode: (self: ListAccountsRequest) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> ListAccountsRequest,
	descriptor: proto.Descriptor,
}

type _ListAccountsRequestFields = {}

type _ListAccountsRequestPartialFields = {}

export type ListAccountsRequest = typeof(setmetatable({} :: _ListAccountsRequestFields, {} :: _ListAccountsRequestImpl))
type _ListAccountsRequestMessage = proto.Message<ListAccountsRequest, _ListAccountsRequestPartialFields>

type _ListAccountsResponseImpl = {
	__index: _ListAccountsResponseImpl,
	new: (fields: _ListAccountsResponsePartialFields?) -> ListAccountsResponse,
	encode: (self: ListAccountsResponse) -> buffer,
	decode: (input: buffer) -> ListAccountsResponse,
	jsonEncode: (self: ListAccountsResponse) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> ListAccountsResponse,
	descriptor: proto.Descriptor,
}

type _ListAccountsResponseFields = {
	accounts: { LinkedAccount },
}

type _ListAccountsResponsePartialFields = {
	accounts: { LinkedAccount }?,
}

export type ListAccountsResponse = typeof(setmetatable(
	{} :: _ListAccountsResponseFields,
	{} :: _ListAccountsResponseImpl
))
type _ListAccountsResponseMessage = proto.Message<ListAccountsResponse, _ListAccountsResponsePartialFields>

type _LinkedAccountImpl = {
	__index: _LinkedAccountImpl,
	new: (fields: _LinkedAccountPartialFields?) -> LinkedAccount,
	encode: (self: LinkedAccount) -> buffer,
	decode: (input: buffer) -> LinkedAccount,
	jsonEncode: (self: LinkedAccount) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> LinkedAccount,
	descriptor: proto.Descriptor,
}

type _LinkedAccountFields = {
	id: string,
	username: string,
	display_name: string?,
	avatar_url: string?,
	linked_at: number,
}

type _LinkedAccountPartialFields = {
	id: string?,
	username: string?,
	display_name: string?,
	avatar_url: string?,
	linked_at: number?,
}

export type LinkedAccount = typeof(setmetatable({} :: _LinkedAccountFields, {} :: _LinkedAccountImpl))
type _LinkedAccountMessage = proto.Message<LinkedAccount, _LinkedAccountPartialFields>

do
	local _ListAccountsRequestImpl = {}
	_ListAccountsRequestImpl.__index = _ListAccountsRequestImpl

	function _ListAccountsRequestImpl.new(data: _ListAccountsRequestPartialFields?): ListAccountsRequest
		return setmetatable({}, _ListAccountsRequestImpl :: _ListAccountsRequestImpl)
	end

	function _ListAccountsRequestImpl.encode(self: ListAccountsRequest): buffer
		local output = buffer.create(0)
		local cursor = 0

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _ListAccountsRequestImpl.decode(input: buffer): ListAccountsRequest
		local self = _ListAccountsRequestImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				-- No fields

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _ListAccountsRequestImpl.jsonEncode(self: ListAccountsRequest): any
		local output = {}

		return output
	end

	function _ListAccountsRequestImpl.jsonDecode(input: { [string]: any }): ListAccountsRequest
		local self = _ListAccountsRequestImpl.new()

		return self
	end

	_ListAccountsRequestImpl.descriptor = {
		name = "ListAccountsRequest",
		fullName = "srp.accounts.ListAccountsRequest",
	}

	messages.ListAccountsRequest = _ListAccountsRequestImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.ListAccountsRequest)
end

do
	local _ListAccountsResponseImpl = {}
	_ListAccountsResponseImpl.__index = _ListAccountsResponseImpl

	function _ListAccountsResponseImpl.new(data: _ListAccountsResponsePartialFields?): ListAccountsResponse
		return setmetatable({
			accounts = if data == nil or data.accounts == nil then {} else data.accounts,
		}, _ListAccountsResponseImpl :: _ListAccountsResponseImpl)
	end

	function _ListAccountsResponseImpl.encode(self: ListAccountsResponse): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.accounts ~= nil and #self.accounts > 0 then
			for _, value in self.accounts do
				local encoded = value:encode()
				output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _ListAccountsResponseImpl.decode(input: buffer): ListAccountsResponse
		local self = _ListAccountsResponseImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					table.insert(self.accounts, messages.LinkedAccount.decode(value))
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _ListAccountsResponseImpl.jsonEncode(self: ListAccountsResponse): any
		local output = {}

		if self.accounts ~= nil and #self.accounts > 0 then
			local newOutput = {}
			for _, value in self.accounts do
				table.insert(newOutput, value:jsonEncode())
			end
			output.accounts = newOutput
		end

		return output
	end

	function _ListAccountsResponseImpl.jsonDecode(input: { [string]: any }): ListAccountsResponse
		local self = _ListAccountsResponseImpl.new()

		if input.accounts ~= nil then
			local newOutput: { LinkedAccount } = {}
			for _, value in input.accounts do
				table.insert(newOutput, messages.LinkedAccount.jsonDecode(value))
			end

			self.accounts = newOutput
		end

		return self
	end

	_ListAccountsResponseImpl.descriptor = {
		name = "ListAccountsResponse",
		fullName = "srp.accounts.ListAccountsResponse",
	}

	messages.ListAccountsResponse = _ListAccountsResponseImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.ListAccountsResponse)
end

do
	local _LinkedAccountImpl = {}
	_LinkedAccountImpl.__index = _LinkedAccountImpl

	function _LinkedAccountImpl.new(data: _LinkedAccountPartialFields?): LinkedAccount
		return setmetatable({
			id = if data == nil or data.id == nil then "" else data.id,
			username = if data == nil or data.username == nil then "" else data.username,
			display_name = if data == nil or data.display_name == nil then nil else data.display_name,
			avatar_url = if data == nil or data.avatar_url == nil then nil else data.avatar_url,
			linked_at = if data == nil or data.linked_at == nil then 0 else data.linked_at,
		}, _LinkedAccountImpl :: _LinkedAccountImpl)
	end

	function _LinkedAccountImpl.encode(self: LinkedAccount): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.id ~= nil and self.id ~= "" then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.id)
		end

		if self.username ~= nil and self.username ~= "" then
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.username)
		end

		if self.display_name ~= nil then
			output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.display_name)
		end

		if self.avatar_url ~= nil then
			output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.avatar_url)
		end

		if self.linked_at ~= nil and self.linked_at ~= 0 then
			output, cursor = proto.writeTag(output, cursor, 5, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, self.linked_at)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _LinkedAccountImpl.decode(input: buffer): LinkedAccount
		local self = _LinkedAccountImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 5 then
					local value
					value, cursor = proto.readVarIntI64(input, cursor)
					self.linked_at = value
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.id = buffer.tostring(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.username = buffer.tostring(value)
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.display_name = buffer.tostring(value)
					continue
				elseif field == 4 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.avatar_url = buffer.tostring(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _LinkedAccountImpl.jsonEncode(self: LinkedAccount): any
		local output = {}

		if self.id ~= nil and self.id ~= "" then
			output.id = self.id
		end

		if self.username ~= nil and self.username ~= "" then
			output.username = self.username
		end

		if self.display_name ~= nil then
			output.displayName = self.display_name
		end

		if self.avatar_url ~= nil then
			output.avatarUrl = self.avatar_url
		end

		if self.linked_at ~= nil and self.linked_at ~= 0 then
			output.linkedAt = self.linked_at
		end

		return output
	end

	function _LinkedAccountImpl.jsonDecode(input: { [string]: any }): LinkedAccount
		local self = _LinkedAccountImpl.new()

		if input.id ~= nil then
			self.id = input.id
		end

		if input.username ~= nil then
			self.username = input.username
		end

		if input.display_name ~= nil then
			self.display_name = input.display_name
		end

		if input.displayName ~= nil then
			self.display_name = input.displayName
		end

		if input.avatar_url ~= nil then
			self.avatar_url = input.avatar_url
		end

		if input.avatarUrl ~= nil then
			self.avatar_url = input.avatarUrl
		end

		if input.linked_at ~= nil then
			self.linked_at = input.linked_at
		end

		if input.linkedAt ~= nil then
			self.linked_at = input.linkedAt
		end

		return self
	end

	_LinkedAccountImpl.descriptor = {
		name = "LinkedAccount",
		fullName = "srp.accounts.LinkedAccount",
	}

	messages.LinkedAccount = _LinkedAccountImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.LinkedAccount)
end

return {
	ListAccountsRequest = messages.ListAccountsRequest,
	ListAccountsResponse = messages.ListAccountsResponse,
	LinkedAccount = messages.LinkedAccount,
}

--!strict
--!nolint LocalUnused
--!nolint ImportUnused
--# selene: allow(empty_if, if_same_then_else, manual_table_clone, unused_variable)
-- This file was @autogenerated by protoc-gen-luau
local proto = require(script.Parent.proto)
local typeRegistry = require(script.Parent.proto.typeRegistry)

type _Messages = {
	AuthStartRequest: _AuthStartRequestMessage,
	AuthStartResponse: _AuthStartResponseMessage,
	AuthCompleteRequest: _AuthCompleteRequestMessage,
	AuthCompleteResponse: _AuthCompleteResponseMessage,
	AuthSseEvent: _AuthSseEventMessage,
	AuthEventType: _AuthEventTypeMessage,
}
local messages: _Messages = {} :: _Messages

local _common = require(script.Parent.common)

type _AuthStartRequestImpl = {
	__index: _AuthStartRequestImpl,
	new: (fields: _AuthStartRequestPartialFields?) -> AuthStartRequest,
	encode: (self: AuthStartRequest) -> buffer,
	decode: (input: buffer) -> AuthStartRequest,
	jsonEncode: (self: AuthStartRequest) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> AuthStartRequest,
	descriptor: proto.Descriptor,
}

type _AuthStartRequestFields = {
	auth_token: string?,
	client_key: string?,
}

type _AuthStartRequestPartialFields = {
	auth_token: string?,
	client_key: string?,
}

export type AuthStartRequest = typeof(setmetatable({} :: _AuthStartRequestFields, {} :: _AuthStartRequestImpl))
type _AuthStartRequestMessage = proto.Message<AuthStartRequest, _AuthStartRequestPartialFields>

type _AuthStartResponseImpl = {
	__index: _AuthStartResponseImpl,
	new: (fields: _AuthStartResponsePartialFields?) -> AuthStartResponse,
	encode: (self: AuthStartResponse) -> buffer,
	decode: (input: buffer) -> AuthStartResponse,
	jsonEncode: (self: AuthStartResponse) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> AuthStartResponse,
	descriptor: proto.Descriptor,
}

type _AuthStartResponseFields = {
	code: string,
	url: string,
	sse_url: string,
	expires_in_seconds: number,
}

type _AuthStartResponsePartialFields = {
	code: string?,
	url: string?,
	sse_url: string?,
	expires_in_seconds: number?,
}

export type AuthStartResponse = typeof(setmetatable({} :: _AuthStartResponseFields, {} :: _AuthStartResponseImpl))
type _AuthStartResponseMessage = proto.Message<AuthStartResponse, _AuthStartResponsePartialFields>

type _AuthCompleteRequestImpl = {
	__index: _AuthCompleteRequestImpl,
	new: (fields: _AuthCompleteRequestPartialFields?) -> AuthCompleteRequest,
	encode: (self: AuthCompleteRequest) -> buffer,
	decode: (input: buffer) -> AuthCompleteRequest,
	jsonEncode: (self: AuthCompleteRequest) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> AuthCompleteRequest,
	descriptor: proto.Descriptor,
}

type _AuthCompleteRequestFields = {
	code: string,
	completion_code: string,
}

type _AuthCompleteRequestPartialFields = {
	code: string?,
	completion_code: string?,
}

export type AuthCompleteRequest = typeof(setmetatable({} :: _AuthCompleteRequestFields, {} :: _AuthCompleteRequestImpl))
type _AuthCompleteRequestMessage = proto.Message<AuthCompleteRequest, _AuthCompleteRequestPartialFields>

type _AuthCompleteResponseImpl = {
	__index: _AuthCompleteResponseImpl,
	new: (fields: _AuthCompleteResponsePartialFields?) -> AuthCompleteResponse,
	encode: (self: AuthCompleteResponse) -> buffer,
	decode: (input: buffer) -> AuthCompleteResponse,
	jsonEncode: (self: AuthCompleteResponse) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> AuthCompleteResponse,
	descriptor: proto.Descriptor,
}

type _AuthCompleteResponseFields = {
	auth_token: string?,
	client_key: string?,
}

type _AuthCompleteResponsePartialFields = {
	auth_token: string?,
	client_key: string?,
}

export type AuthCompleteResponse = typeof(setmetatable(
	{} :: _AuthCompleteResponseFields,
	{} :: _AuthCompleteResponseImpl
))
type _AuthCompleteResponseMessage = proto.Message<AuthCompleteResponse, _AuthCompleteResponsePartialFields>

type _AuthSseEventImpl = {
	__index: _AuthSseEventImpl,
	new: (fields: _AuthSseEventPartialFields?) -> AuthSseEvent,
	encode: (self: AuthSseEvent) -> buffer,
	decode: (input: buffer) -> AuthSseEvent,
	jsonEncode: (self: AuthSseEvent) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> AuthSseEvent,
	descriptor: proto.Descriptor,
}

type _AuthSseEventFields = {
	type: AuthEventType,
	completion: AuthCompleteResponse?,
	error_message: string?,
}

type _AuthSseEventPartialFields = {
	type: AuthEventType?,
	completion: AuthCompleteResponse?,
	error_message: string?,
}

export type AuthSseEvent = typeof(setmetatable({} :: _AuthSseEventFields, {} :: _AuthSseEventImpl))
type _AuthSseEventMessage = proto.Message<AuthSseEvent, _AuthSseEventPartialFields>

type _AuthEventTypeMessage = proto.Enum<AuthEventType>
export type AuthEventType =
	"AUTH_EVENT_TYPE_UNSPECIFIED"
	| "AUTH_EVENT_TYPE_HEARTBEAT"
	| "AUTH_EVENT_TYPE_STARTED"
	| "AUTH_EVENT_TYPE_COMPLETED"
	| "AUTH_EVENT_TYPE_FAILED"
	| "AUTH_EVENT_TYPE_EXPIRED"
	| number -- Unknown

do
	local _AuthStartRequestImpl = {}
	_AuthStartRequestImpl.__index = _AuthStartRequestImpl

	function _AuthStartRequestImpl.new(data: _AuthStartRequestPartialFields?): AuthStartRequest
		return setmetatable({
			auth_token = if data == nil or data.auth_token == nil then nil else data.auth_token,
			client_key = if data == nil or data.client_key == nil then nil else data.client_key,
		}, _AuthStartRequestImpl :: _AuthStartRequestImpl)
	end

	function _AuthStartRequestImpl.encode(self: AuthStartRequest): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.auth_token ~= nil then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.auth_token)
		end

		if self.client_key ~= nil then
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.client_key)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _AuthStartRequestImpl.decode(input: buffer): AuthStartRequest
		local self = _AuthStartRequestImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.auth_token = buffer.tostring(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.client_key = buffer.tostring(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _AuthStartRequestImpl.jsonEncode(self: AuthStartRequest): any
		local output = {}

		if self.auth_token ~= nil then
			output.authToken = self.auth_token
		end

		if self.client_key ~= nil then
			output.clientKey = self.client_key
		end

		return output
	end

	function _AuthStartRequestImpl.jsonDecode(input: { [string]: any }): AuthStartRequest
		local self = _AuthStartRequestImpl.new()

		if input.auth_token ~= nil then
			self.auth_token = input.auth_token
		end

		if input.authToken ~= nil then
			self.auth_token = input.authToken
		end

		if input.client_key ~= nil then
			self.client_key = input.client_key
		end

		if input.clientKey ~= nil then
			self.client_key = input.clientKey
		end

		return self
	end

	_AuthStartRequestImpl.descriptor = {
		name = "AuthStartRequest",
		fullName = "srp.auth.AuthStartRequest",
	}

	messages.AuthStartRequest = _AuthStartRequestImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.AuthStartRequest)
end

do
	local _AuthStartResponseImpl = {}
	_AuthStartResponseImpl.__index = _AuthStartResponseImpl

	function _AuthStartResponseImpl.new(data: _AuthStartResponsePartialFields?): AuthStartResponse
		return setmetatable({
			code = if data == nil or data.code == nil then "" else data.code,
			url = if data == nil or data.url == nil then "" else data.url,
			sse_url = if data == nil or data.sse_url == nil then "" else data.sse_url,
			expires_in_seconds = if data == nil or data.expires_in_seconds == nil then 0 else data.expires_in_seconds,
		}, _AuthStartResponseImpl :: _AuthStartResponseImpl)
	end

	function _AuthStartResponseImpl.encode(self: AuthStartResponse): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.code ~= nil and self.code ~= "" then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.code)
		end

		if self.url ~= nil and self.url ~= "" then
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.url)
		end

		if self.sse_url ~= nil and self.sse_url ~= "" then
			output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.sse_url)
		end

		if self.expires_in_seconds ~= nil and self.expires_in_seconds ~= 0 then
			output, cursor = proto.writeTag(output, cursor, 4, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, self.expires_in_seconds)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _AuthStartResponseImpl.decode(input: buffer): AuthStartResponse
		local self = _AuthStartResponseImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 4 then
					local value
					value, cursor = proto.readVarIntI32(input, cursor)
					self.expires_in_seconds = value
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.code = buffer.tostring(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.url = buffer.tostring(value)
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.sse_url = buffer.tostring(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _AuthStartResponseImpl.jsonEncode(self: AuthStartResponse): any
		local output = {}

		if self.code ~= nil and self.code ~= "" then
			output.code = self.code
		end

		if self.url ~= nil and self.url ~= "" then
			output.url = self.url
		end

		if self.sse_url ~= nil and self.sse_url ~= "" then
			output.sseUrl = self.sse_url
		end

		if self.expires_in_seconds ~= nil and self.expires_in_seconds ~= 0 then
			output.expiresInSeconds = self.expires_in_seconds
		end

		return output
	end

	function _AuthStartResponseImpl.jsonDecode(input: { [string]: any }): AuthStartResponse
		local self = _AuthStartResponseImpl.new()

		if input.code ~= nil then
			self.code = input.code
		end

		if input.url ~= nil then
			self.url = input.url
		end

		if input.sse_url ~= nil then
			self.sse_url = input.sse_url
		end

		if input.sseUrl ~= nil then
			self.sse_url = input.sseUrl
		end

		if input.expires_in_seconds ~= nil then
			self.expires_in_seconds = input.expires_in_seconds
		end

		if input.expiresInSeconds ~= nil then
			self.expires_in_seconds = input.expiresInSeconds
		end

		return self
	end

	_AuthStartResponseImpl.descriptor = {
		name = "AuthStartResponse",
		fullName = "srp.auth.AuthStartResponse",
	}

	messages.AuthStartResponse = _AuthStartResponseImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.AuthStartResponse)
end

do
	local _AuthCompleteRequestImpl = {}
	_AuthCompleteRequestImpl.__index = _AuthCompleteRequestImpl

	function _AuthCompleteRequestImpl.new(data: _AuthCompleteRequestPartialFields?): AuthCompleteRequest
		return setmetatable({
			code = if data == nil or data.code == nil then "" else data.code,
			completion_code = if data == nil or data.completion_code == nil then "" else data.completion_code,
		}, _AuthCompleteRequestImpl :: _AuthCompleteRequestImpl)
	end

	function _AuthCompleteRequestImpl.encode(self: AuthCompleteRequest): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.code ~= nil and self.code ~= "" then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.code)
		end

		if self.completion_code ~= nil and self.completion_code ~= "" then
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.completion_code)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _AuthCompleteRequestImpl.decode(input: buffer): AuthCompleteRequest
		local self = _AuthCompleteRequestImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.code = buffer.tostring(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.completion_code = buffer.tostring(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _AuthCompleteRequestImpl.jsonEncode(self: AuthCompleteRequest): any
		local output = {}

		if self.code ~= nil and self.code ~= "" then
			output.code = self.code
		end

		if self.completion_code ~= nil and self.completion_code ~= "" then
			output.completionCode = self.completion_code
		end

		return output
	end

	function _AuthCompleteRequestImpl.jsonDecode(input: { [string]: any }): AuthCompleteRequest
		local self = _AuthCompleteRequestImpl.new()

		if input.code ~= nil then
			self.code = input.code
		end

		if input.completion_code ~= nil then
			self.completion_code = input.completion_code
		end

		if input.completionCode ~= nil then
			self.completion_code = input.completionCode
		end

		return self
	end

	_AuthCompleteRequestImpl.descriptor = {
		name = "AuthCompleteRequest",
		fullName = "srp.auth.AuthCompleteRequest",
	}

	messages.AuthCompleteRequest = _AuthCompleteRequestImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.AuthCompleteRequest)
end

do
	local _AuthCompleteResponseImpl = {}
	_AuthCompleteResponseImpl.__index = _AuthCompleteResponseImpl

	function _AuthCompleteResponseImpl.new(data: _AuthCompleteResponsePartialFields?): AuthCompleteResponse
		return setmetatable({
			auth_token = if data == nil or data.auth_token == nil then nil else data.auth_token,
			client_key = if data == nil or data.client_key == nil then nil else data.client_key,
		}, _AuthCompleteResponseImpl :: _AuthCompleteResponseImpl)
	end

	function _AuthCompleteResponseImpl.encode(self: AuthCompleteResponse): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.auth_token ~= nil then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.auth_token)
		end

		if self.client_key ~= nil then
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.client_key)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _AuthCompleteResponseImpl.decode(input: buffer): AuthCompleteResponse
		local self = _AuthCompleteResponseImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.auth_token = buffer.tostring(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.client_key = buffer.tostring(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _AuthCompleteResponseImpl.jsonEncode(self: AuthCompleteResponse): any
		local output = {}

		if self.auth_token ~= nil then
			output.authToken = self.auth_token
		end

		if self.client_key ~= nil then
			output.clientKey = self.client_key
		end

		return output
	end

	function _AuthCompleteResponseImpl.jsonDecode(input: { [string]: any }): AuthCompleteResponse
		local self = _AuthCompleteResponseImpl.new()

		if input.auth_token ~= nil then
			self.auth_token = input.auth_token
		end

		if input.authToken ~= nil then
			self.auth_token = input.authToken
		end

		if input.client_key ~= nil then
			self.client_key = input.client_key
		end

		if input.clientKey ~= nil then
			self.client_key = input.clientKey
		end

		return self
	end

	_AuthCompleteResponseImpl.descriptor = {
		name = "AuthCompleteResponse",
		fullName = "srp.auth.AuthCompleteResponse",
	}

	messages.AuthCompleteResponse = _AuthCompleteResponseImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.AuthCompleteResponse)
end

do
	local _AuthSseEventImpl = {}
	_AuthSseEventImpl.__index = _AuthSseEventImpl

	function _AuthSseEventImpl.new(data: _AuthSseEventPartialFields?): AuthSseEvent
		return setmetatable({
			type = if data == nil or data.type == nil
				then assert(messages.AuthEventType.fromNumber(0), "Enum has no 0 default")
				else data.type,
			completion = if data == nil or data.completion == nil then nil else data.completion,
			error_message = if data == nil or data.error_message == nil then nil else data.error_message,
		}, _AuthSseEventImpl :: _AuthSseEventImpl)
	end

	function _AuthSseEventImpl.encode(self: AuthSseEvent): buffer
		local output = buffer.create(0)
		local cursor = 0

		if
			self.type ~= nil
			and (self.type ~= nil and self.type ~= 0 or self.type ~= messages.AuthEventType.fromNumber(0))
		then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, messages.AuthEventType.toNumber(self.type :: any))
		end

		if self.completion ~= nil then
			local encoded = self.completion:encode()
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeBuffer(output, cursor, encoded, buffer.len(encoded))
		end

		if self.error_message ~= nil then
			output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.error_message)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _AuthSseEventImpl.decode(input: buffer): AuthSseEvent
		local self = _AuthSseEventImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 1 then
					local value
					value, cursor = proto.readVarIntI32(input, cursor)
					self.type = (messages.AuthEventType.fromNumber(value) or value) :: any --[[ Luau: Enums are a string intersection which Luau is quick to dismantle ]]
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.completion = messages.AuthCompleteResponse.decode(value)
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.error_message = buffer.tostring(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _AuthSseEventImpl.jsonEncode(self: AuthSseEvent): any
		local output = {}

		if
			self.type ~= nil
			and (self.type ~= nil and self.type ~= 0 or self.type ~= messages.AuthEventType.fromNumber(0))
		then
			output.type = if typeof(self.type) == "number"
				then self.type
				else messages.AuthEventType.toNumber(self.type :: any)
		end

		if self.completion ~= nil then
			output.completion = self.completion:jsonEncode()
		end

		if self.error_message ~= nil then
			output.errorMessage = self.error_message
		end

		return output
	end

	function _AuthSseEventImpl.jsonDecode(input: { [string]: any }): AuthSseEvent
		local self = _AuthSseEventImpl.new()

		if input.type ~= nil then
			self.type = if typeof(input.type) == "number"
				then (messages.AuthEventType.fromNumber(input.type) or input.type)
				else (messages.AuthEventType.fromName(input.type) or input.type)
		end

		if input.completion ~= nil then
			self.completion = messages.AuthCompleteResponse.jsonDecode(input.completion)
		end

		if input.error_message ~= nil then
			self.error_message = input.error_message
		end

		if input.errorMessage ~= nil then
			self.error_message = input.errorMessage
		end

		return self
	end

	_AuthSseEventImpl.descriptor = {
		name = "AuthSseEvent",
		fullName = "srp.auth.AuthSseEvent",
	}

	messages.AuthSseEvent = _AuthSseEventImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.AuthSseEvent)
end

messages.AuthEventType = {
	fromNumber = function(value: number): AuthEventType?
		if value == 0 then
			return "AUTH_EVENT_TYPE_UNSPECIFIED"
		elseif value == 1 then
			return "AUTH_EVENT_TYPE_HEARTBEAT"
		elseif value == 2 then
			return "AUTH_EVENT_TYPE_STARTED"
		elseif value == 3 then
			return "AUTH_EVENT_TYPE_COMPLETED"
		elseif value == 4 then
			return "AUTH_EVENT_TYPE_FAILED"
		elseif value == 5 then
			return "AUTH_EVENT_TYPE_EXPIRED"
		else
			return nil
		end
	end,

	toNumber = function(self: AuthEventType): number
		if self == "AUTH_EVENT_TYPE_UNSPECIFIED" then
			return 0
		elseif self == "AUTH_EVENT_TYPE_HEARTBEAT" then
			return 1
		elseif self == "AUTH_EVENT_TYPE_STARTED" then
			return 2
		elseif self == "AUTH_EVENT_TYPE_COMPLETED" then
			return 3
		elseif self == "AUTH_EVENT_TYPE_FAILED" then
			return 4
		elseif self == "AUTH_EVENT_TYPE_EXPIRED" then
			return 5
		else
			return self
		end
	end,

	fromName = function(name: string): AuthEventType?
		if name == "AUTH_EVENT_TYPE_UNSPECIFIED" then
			return "AUTH_EVENT_TYPE_UNSPECIFIED"
		elseif name == "AUTH_EVENT_TYPE_HEARTBEAT" then
			return "AUTH_EVENT_TYPE_HEARTBEAT"
		elseif name == "AUTH_EVENT_TYPE_STARTED" then
			return "AUTH_EVENT_TYPE_STARTED"
		elseif name == "AUTH_EVENT_TYPE_COMPLETED" then
			return "AUTH_EVENT_TYPE_COMPLETED"
		elseif name == "AUTH_EVENT_TYPE_FAILED" then
			return "AUTH_EVENT_TYPE_FAILED"
		elseif name == "AUTH_EVENT_TYPE_EXPIRED" then
			return "AUTH_EVENT_TYPE_EXPIRED"
		else
			return nil
		end
	end,
}

return {
	AuthStartRequest = messages.AuthStartRequest,
	AuthStartResponse = messages.AuthStartResponse,
	AuthCompleteRequest = messages.AuthCompleteRequest,
	AuthCompleteResponse = messages.AuthCompleteResponse,
	AuthSseEvent = messages.AuthSseEvent,
	AuthEventType = messages.AuthEventType,
}

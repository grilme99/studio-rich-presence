--!strict
--!nolint LocalUnused
--!nolint ImportUnused
--# selene: allow(empty_if, if_same_then_else, manual_table_clone, unused_variable)
-- This file was @autogenerated by protoc-gen-luau
local proto = require(script.Parent.proto)
local typeRegistry = require(script.Parent.proto.typeRegistry)

type _Messages = {
	ErrorResponse: _ErrorResponseMessage,
	ErrorResponse_DetailsEntry: _ErrorResponse_DetailsEntryMessage,
	Timestamp: _TimestampMessage,
	ErrorCode: _ErrorCodeMessage,
}
local messages: _Messages = {} :: _Messages

type _ErrorResponseImpl = {
	__index: _ErrorResponseImpl,
	new: (fields: _ErrorResponsePartialFields?) -> ErrorResponse,
	encode: (self: ErrorResponse) -> buffer,
	decode: (input: buffer) -> ErrorResponse,
	jsonEncode: (self: ErrorResponse) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> ErrorResponse,
	descriptor: proto.Descriptor,
}

type _ErrorResponseFields = {
	code: ErrorCode,
	message: string,
	details: { [string]: string },
}

type _ErrorResponsePartialFields = {
	code: ErrorCode?,
	message: string?,
	details: { [string]: string }?,
}

export type ErrorResponse = typeof(setmetatable({} :: _ErrorResponseFields, {} :: _ErrorResponseImpl))
type _ErrorResponseMessage = proto.Message<ErrorResponse, _ErrorResponsePartialFields>

type _ErrorResponse_DetailsEntryImpl = {
	__index: _ErrorResponse_DetailsEntryImpl,
	new: (fields: _ErrorResponse_DetailsEntryPartialFields?) -> ErrorResponse_DetailsEntry,
	encode: (self: ErrorResponse_DetailsEntry) -> buffer,
	decode: (input: buffer) -> ErrorResponse_DetailsEntry,
	jsonEncode: (self: ErrorResponse_DetailsEntry) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> ErrorResponse_DetailsEntry,
	descriptor: proto.Descriptor,
}

type _ErrorResponse_DetailsEntryFields = {
	key: string,
	value: string,
}

type _ErrorResponse_DetailsEntryPartialFields = {
	key: string?,
	value: string?,
}

export type ErrorResponse_DetailsEntry = typeof(setmetatable(
	{} :: _ErrorResponse_DetailsEntryFields,
	{} :: _ErrorResponse_DetailsEntryImpl
))
type _ErrorResponse_DetailsEntryMessage = proto.Message<
	ErrorResponse_DetailsEntry,
	_ErrorResponse_DetailsEntryPartialFields
>

type _TimestampImpl = {
	__index: _TimestampImpl,
	new: (fields: _TimestampPartialFields?) -> Timestamp,
	encode: (self: Timestamp) -> buffer,
	decode: (input: buffer) -> Timestamp,
	jsonEncode: (self: Timestamp) -> { [string]: any },
	jsonDecode: (input: { [string]: any }) -> Timestamp,
	descriptor: proto.Descriptor,
}

type _TimestampFields = {
	unix_ms: number,
}

type _TimestampPartialFields = {
	unix_ms: number?,
}

export type Timestamp = typeof(setmetatable({} :: _TimestampFields, {} :: _TimestampImpl))
type _TimestampMessage = proto.Message<Timestamp, _TimestampPartialFields>

type _ErrorCodeMessage = proto.Enum<ErrorCode>
export type ErrorCode =
	"ERROR_CODE_UNSPECIFIED"
	| "ERROR_CODE_INVALID_REQUEST"
	| "ERROR_CODE_UNAUTHORIZED"
	| "ERROR_CODE_FORBIDDEN"
	| "ERROR_CODE_NOT_FOUND"
	| "ERROR_CODE_RATE_LIMITED"
	| "ERROR_CODE_INTERNAL"
	| "ERROR_CODE_DISCORD_API_ERROR"
	| "ERROR_CODE_SESSION_EXPIRED"
	| "ERROR_CODE_INVALID_COMPLETION_CODE"
	| number -- Unknown

do
	local _ErrorResponseImpl = {}
	_ErrorResponseImpl.__index = _ErrorResponseImpl

	function _ErrorResponseImpl.new(data: _ErrorResponsePartialFields?): ErrorResponse
		return setmetatable({
			code = if data == nil or data.code == nil
				then assert(messages.ErrorCode.fromNumber(0), "Enum has no 0 default")
				else data.code,
			message = if data == nil or data.message == nil then "" else data.message,
			details = if data == nil or data.details == nil then {} else data.details,
		}, _ErrorResponseImpl :: _ErrorResponseImpl)
	end

	function _ErrorResponseImpl.encode(self: ErrorResponse): buffer
		local output = buffer.create(0)
		local cursor = 0

		if
			self.code ~= nil and (self.code ~= nil and self.code ~= 0 or self.code ~= messages.ErrorCode.fromNumber(0))
		then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, messages.ErrorCode.toNumber(self.code :: any))
		end

		if self.message ~= nil and self.message ~= "" then
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.message)
		end

		if self.details ~= nil and next(self.details) ~= nil then
			for key, value in self.details do
				local mapBuffer = buffer.create(0)
				local mapCursor = 0
				mapBuffer, mapCursor = proto.writeTag(mapBuffer, mapCursor, 1, proto.wireTypes.lengthDelimited)
				mapBuffer, mapCursor = proto.writeString(mapBuffer, mapCursor, key)
				mapBuffer, mapCursor = proto.writeTag(mapBuffer, mapCursor, 2, proto.wireTypes.lengthDelimited)
				mapBuffer, mapCursor = proto.writeString(mapBuffer, mapCursor, value)
				output, cursor = proto.writeTag(output, cursor, 3, proto.wireTypes.lengthDelimited)
				output, cursor = proto.writeBuffer(output, cursor, mapBuffer, mapCursor)
			end
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _ErrorResponseImpl.decode(input: buffer): ErrorResponse
		local self = _ErrorResponseImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 1 then
					local value
					value, cursor = proto.readVarIntI32(input, cursor)
					self.code = (messages.ErrorCode.fromNumber(value) or value) :: any --[[ Luau: Enums are a string intersection which Luau is quick to dismantle ]]
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.message = buffer.tostring(value)
					continue
				elseif field == 3 then
					local value
					value, cursor = proto.readBuffer(input, cursor)

					local mapEntry = messages.ErrorResponse_DetailsEntry.decode(value)

					local keyDefault = ""
					local valueDefault = ""

					self.details[mapEntry.key or keyDefault] = mapEntry.value or valueDefault

					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _ErrorResponseImpl.jsonEncode(self: ErrorResponse): any
		local output = {}

		if
			self.code ~= nil and (self.code ~= nil and self.code ~= 0 or self.code ~= messages.ErrorCode.fromNumber(0))
		then
			output.code = if typeof(self.code) == "number"
				then self.code
				else messages.ErrorCode.toNumber(self.code :: any)
		end

		if self.message ~= nil and self.message ~= "" then
			output.message = self.message
		end

		if self.details ~= nil and next(self.details) ~= nil then
			local newOutput = {}
			for key, value in self.details do
				newOutput[key] = value
			end
			output.details = newOutput
		end

		return output
	end

	function _ErrorResponseImpl.jsonDecode(input: { [string]: any }): ErrorResponse
		local self = _ErrorResponseImpl.new()

		if input.code ~= nil then
			self.code = if typeof(input.code) == "number"
				then (messages.ErrorCode.fromNumber(input.code) or input.code)
				else (messages.ErrorCode.fromName(input.code) or input.code)
		end

		if input.message ~= nil then
			self.message = input.message
		end

		if input.details ~= nil then
			local newOutput: { [string]: string } = {}
			for key, value in input.details do
				newOutput[key] = value
			end

			self.details = newOutput
		end

		return self
	end

	_ErrorResponseImpl.descriptor = {
		name = "ErrorResponse",
		fullName = "srp.ErrorResponse",
	}

	messages.ErrorResponse = _ErrorResponseImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.ErrorResponse)
end

do
	local _ErrorResponse_DetailsEntryImpl = {}
	_ErrorResponse_DetailsEntryImpl.__index = _ErrorResponse_DetailsEntryImpl

	function _ErrorResponse_DetailsEntryImpl.new(
		data: _ErrorResponse_DetailsEntryPartialFields?
	): ErrorResponse_DetailsEntry
		return setmetatable({
			key = if data == nil or data.key == nil then "" else data.key,
			value = if data == nil or data.value == nil then "" else data.value,
		}, _ErrorResponse_DetailsEntryImpl :: _ErrorResponse_DetailsEntryImpl)
	end

	function _ErrorResponse_DetailsEntryImpl.encode(self: ErrorResponse_DetailsEntry): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.key ~= nil and self.key ~= "" then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.key)
		end

		if self.value ~= nil and self.value ~= "" then
			output, cursor = proto.writeTag(output, cursor, 2, proto.wireTypes.lengthDelimited)
			output, cursor = proto.writeString(output, cursor, self.value)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _ErrorResponse_DetailsEntryImpl.decode(input: buffer): ErrorResponse_DetailsEntry
		local self = _ErrorResponse_DetailsEntryImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				-- No fields

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				if field == 1 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.key = buffer.tostring(value)
					continue
				elseif field == 2 then
					local value
					value, cursor = proto.readBuffer(input, cursor)
					self.value = buffer.tostring(value)
					continue
				end

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _ErrorResponse_DetailsEntryImpl.jsonEncode(self: ErrorResponse_DetailsEntry): any
		local output = {}

		if self.key ~= nil and self.key ~= "" then
			output.key = self.key
		end

		if self.value ~= nil and self.value ~= "" then
			output.value = self.value
		end

		return output
	end

	function _ErrorResponse_DetailsEntryImpl.jsonDecode(input: { [string]: any }): ErrorResponse_DetailsEntry
		local self = _ErrorResponse_DetailsEntryImpl.new()

		if input.key ~= nil then
			self.key = input.key
		end

		if input.value ~= nil then
			self.value = input.value
		end

		return self
	end

	_ErrorResponse_DetailsEntryImpl.descriptor = {
		name = "ErrorResponse_DetailsEntry",
		fullName = "srp.DetailsEntry",
	}

	messages.ErrorResponse_DetailsEntry = _ErrorResponse_DetailsEntryImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.ErrorResponse_DetailsEntry)
end

do
	local _TimestampImpl = {}
	_TimestampImpl.__index = _TimestampImpl

	function _TimestampImpl.new(data: _TimestampPartialFields?): Timestamp
		return setmetatable({
			unix_ms = if data == nil or data.unix_ms == nil then 0 else data.unix_ms,
		}, _TimestampImpl :: _TimestampImpl)
	end

	function _TimestampImpl.encode(self: Timestamp): buffer
		local output = buffer.create(0)
		local cursor = 0

		if self.unix_ms ~= nil and self.unix_ms ~= 0 then
			output, cursor = proto.writeTag(output, cursor, 1, proto.wireTypes.varint)
			output, cursor = proto.writeVarInt(output, cursor, self.unix_ms)
		end

		local shrunkBuffer = buffer.create(cursor)
		buffer.copy(shrunkBuffer, 0, output, 0, cursor)
		return shrunkBuffer
	end

	function _TimestampImpl.decode(input: buffer): Timestamp
		local self = _TimestampImpl.new()
		local cursor = 0

		while cursor < buffer.len(input) do
			local field, wireType
			field, wireType, cursor = proto.readTag(input, cursor)

			if wireType == proto.wireTypes.varint then
				if field == 1 then
					local value
					value, cursor = proto.readVarIntI64(input, cursor)
					self.unix_ms = value
					continue
				end

				local _
				_, cursor = proto.readVarInt(input, cursor)
			elseif wireType == proto.wireTypes.lengthDelimited then
				-- No fields

				local length
				length, cursor = proto.readVarInt(input, cursor)

				cursor += length
			elseif wireType == proto.wireTypes.i32 then
				-- No fields

				local _
				_, cursor = proto.readFixed32(input, cursor)
			elseif wireType == proto.wireTypes.i64 then
				-- No fields

				local _
				_, cursor = proto.readFixed64(input, cursor)
			else
				error("Unsupported wire type: " .. wireType)
			end
		end

		return self
	end

	function _TimestampImpl.jsonEncode(self: Timestamp): any
		local output = {}

		if self.unix_ms ~= nil and self.unix_ms ~= 0 then
			output.unixMs = self.unix_ms
		end

		return output
	end

	function _TimestampImpl.jsonDecode(input: { [string]: any }): Timestamp
		local self = _TimestampImpl.new()

		if input.unix_ms ~= nil then
			self.unix_ms = input.unix_ms
		end

		if input.unixMs ~= nil then
			self.unix_ms = input.unixMs
		end

		return self
	end

	_TimestampImpl.descriptor = {
		name = "Timestamp",
		fullName = "srp.Timestamp",
	}

	messages.Timestamp = _TimestampImpl :: any -- Luau: Not sure why this intersection fails.

	typeRegistry.default:register(messages.Timestamp)
end

messages.ErrorCode = {
	fromNumber = function(value: number): ErrorCode?
		if value == 0 then
			return "ERROR_CODE_UNSPECIFIED"
		elseif value == 1 then
			return "ERROR_CODE_INVALID_REQUEST"
		elseif value == 2 then
			return "ERROR_CODE_UNAUTHORIZED"
		elseif value == 3 then
			return "ERROR_CODE_FORBIDDEN"
		elseif value == 4 then
			return "ERROR_CODE_NOT_FOUND"
		elseif value == 5 then
			return "ERROR_CODE_RATE_LIMITED"
		elseif value == 6 then
			return "ERROR_CODE_INTERNAL"
		elseif value == 7 then
			return "ERROR_CODE_DISCORD_API_ERROR"
		elseif value == 8 then
			return "ERROR_CODE_SESSION_EXPIRED"
		elseif value == 9 then
			return "ERROR_CODE_INVALID_COMPLETION_CODE"
		else
			return nil
		end
	end,

	toNumber = function(self: ErrorCode): number
		if self == "ERROR_CODE_UNSPECIFIED" then
			return 0
		elseif self == "ERROR_CODE_INVALID_REQUEST" then
			return 1
		elseif self == "ERROR_CODE_UNAUTHORIZED" then
			return 2
		elseif self == "ERROR_CODE_FORBIDDEN" then
			return 3
		elseif self == "ERROR_CODE_NOT_FOUND" then
			return 4
		elseif self == "ERROR_CODE_RATE_LIMITED" then
			return 5
		elseif self == "ERROR_CODE_INTERNAL" then
			return 6
		elseif self == "ERROR_CODE_DISCORD_API_ERROR" then
			return 7
		elseif self == "ERROR_CODE_SESSION_EXPIRED" then
			return 8
		elseif self == "ERROR_CODE_INVALID_COMPLETION_CODE" then
			return 9
		else
			return self
		end
	end,

	fromName = function(name: string): ErrorCode?
		if name == "ERROR_CODE_UNSPECIFIED" then
			return "ERROR_CODE_UNSPECIFIED"
		elseif name == "ERROR_CODE_INVALID_REQUEST" then
			return "ERROR_CODE_INVALID_REQUEST"
		elseif name == "ERROR_CODE_UNAUTHORIZED" then
			return "ERROR_CODE_UNAUTHORIZED"
		elseif name == "ERROR_CODE_FORBIDDEN" then
			return "ERROR_CODE_FORBIDDEN"
		elseif name == "ERROR_CODE_NOT_FOUND" then
			return "ERROR_CODE_NOT_FOUND"
		elseif name == "ERROR_CODE_RATE_LIMITED" then
			return "ERROR_CODE_RATE_LIMITED"
		elseif name == "ERROR_CODE_INTERNAL" then
			return "ERROR_CODE_INTERNAL"
		elseif name == "ERROR_CODE_DISCORD_API_ERROR" then
			return "ERROR_CODE_DISCORD_API_ERROR"
		elseif name == "ERROR_CODE_SESSION_EXPIRED" then
			return "ERROR_CODE_SESSION_EXPIRED"
		elseif name == "ERROR_CODE_INVALID_COMPLETION_CODE" then
			return "ERROR_CODE_INVALID_COMPLETION_CODE"
		else
			return nil
		end
	end,
}

return {
	ErrorResponse = messages.ErrorResponse,
	Timestamp = messages.Timestamp,
	ErrorCode = messages.ErrorCode,
}
